# BF、KMP、KMP的改进

## BF算法

```c++
int bruteForce(string text, string pattern)
{
    int n = text.length();    // 获取文本的长度
    int m = pattern.length(); // 获取模式的长度

    // 从文本的第一个字符开始逐个比较
    for (int i = 0; i <= n - m; i++)
    { // i 表示文本中当前比较的起始位置
        int j;
        for (j = 0; j < m; j++)
        {                                  // j 表示模式中当前比较的字符位置
            if (text[i + j] != pattern[j]) // 如果当前字符不匹配，则退出内层循环
                break;
        }

        if (j == m)   // 如果内层循环正常结束，且 j 等于 m，说明找到了匹配的子串
            return i; // 返回匹配的起始位置
    }

    return -1; // 没有找到匹配的子串
}
```

在上述代码中， `bruteForce` 函数接受两个字符串参数 `text` 和 `pattern` ，并返回匹配的起始位置。在 `main` 函数中，我们定义了一个文本字符串 `text` 和一个模式字符串 `pattern` ，然后调用 `bruteForce` 函数进行匹配，并输出结果。 该暴力匹配算法的思想是，从文本的第一个字符开始，逐个比较字符是否与模式的对应位置字符相同，如果不同，则继续向后移动一个字符，直到找到匹配的子串或遍历完整个文本。如果找到匹配的子串，则返回起始位置；否则，返回 -1 表示没有找到匹配的子串。

## KMP算法

### next数组

```c++
int *next = new int[m];
    next[0] = -1;
    for (int i = 1; i < m; i++) {
        int j = next[i - 1];
        while (j >= 0 && pattern[i] != pattern[j + 1]) {
            j = next[j];
        }
        next[i] = j + 1;
    }
```

`kmp1_0` 函数是 KMP 算法的核心函数。该函数的输入参数是文本字符串 `text` 和模式字符串 `pattern` 。该函数首先计算模式字符串的 next 数组

next 数组就是记录了 pattern 字符串中每个前缀子串的最长公共前后缀长度，用于在匹配失败时快速跳过已匹配的前缀子串。

首先申请一个长度为 m 的整型数组 next，第一个元素赋值为 -1。然后从第二个元素开始遍历，每次取上一个元素的值 j，如果 pattern[i] 与 pattern[j+1] 不相等，则将 j 更新为 next[j]，直到找到相等的位置或者 j=-1 时退出循环，最后将 next[i] 赋值为 j+1。

```c++
// 初始化匹配起始位置和当前位置
    int i = 0;
    int j = 0;

    // 遍历文本字符串
    while (i < n)
    {
        // 当前字符匹配成功
        if (text[i] == pattern[j])
        {
            i++;
            j++;
        }

        // 当前字符匹配失败
        else if (j > 0)
        {
            j = next[j - 1];
        }

        // 模式字符串匹配成功
        else
        {
            i++;
        }

        // 模式字符串匹配到末尾
        if (j == m)
        {
            return i - m;
        }
    }
    // 模式字符串没有匹配到
    return -1;
```

在匹配过程中，如果当前字符匹配成功，则 i 和 j 都加 1。如果当前字符匹配失败，则 j 回退到 next[j - 1] 的位置。如果 j 等于 m，则说明模式字符串匹配成功，返回 i - m。否则，继续匹配。 KMP 算法的时间复杂度为 O(n)，空间复杂度为 O(m)。KMP 算法是字符串匹配算法中比较高效的一种算法。

## KMP算法改进

```c++
void buildNext(const string &pattern, int *next)
{
    int m = pattern.length();
    next[0] = -1;      // 初始化next[0]为-1
    int i = 0, j = -1; // i表示当前字符的位置，j表示当前字符之前的最长可匹配前缀的下一个字符的位置

    while (i < m - 1)
    {
        if (j == -1 || pattern[i] == pattern[j])
        {
            ++i;
            ++j;
            if (pattern[i] != pattern[j])
            {
                next[i] = j; // 当前字符与前缀不匹配时，next[i]的值为j
            }
            else
            {
                next[i] = next[j]; // 当前字符与前缀匹配时，next[i]的值与next[j]相同
            }
        }
        else
        {
            j = next[j]; // 当前字符与前缀不匹配时，j回退到next[j]的位置
        }
    }
}
```

1. 首先获取模式串的长度m。 

2. 初始化next[0]为-1，表示模式串的第一个字符之前没有可匹配的前缀。 

3. 初始化i为0，表示当前字符的位置；初始化j为-1，表示当前字符之前的最长可匹配前缀的下一个字符的位置。

4. 进入循环，当i小于m-1时进行以下操作： 
   1.如果j等于-1或者当前字符与前缀字符相等，说明可以继续匹配下一个字符。 
   2.将i和j都加1，表示匹配成功的字符数量增加。 
   3.如果当前字符与前缀字符不相等，将next[i]的值设为j，表示当前字符与前缀不匹配时，下一个可能匹配的位置为j。 
   4.如果当前字符与前缀字符相等，将next[i]的值设为next[j]，表示当前字符与前缀匹配时，下一个可能匹配的位置与前缀的下一个可能匹配的位置相同。 
   5.如果当前字符与前缀字符不相等，将j回退到next[j]的位置，继续尝试匹配。 
   6.循环结束后，next数组就构建完成了。

在普通的next数组构建方式中，通常使用两个指针i和j来比较模式串中的字符。如果当前字符与前缀字符相等，则将next[i]的值设为j，表示当前字符与前缀不匹配时，下一个可能匹配的位置为j。如果当前字符与前缀字符不相等，则将j回退到上一个可能匹配的位置，继续尝试匹配。 而在这段代码中，使用了两个指针i和j来构建next数组，但在比较字符时，采用了一种更简洁的方式。如果当前字符与前缀字符相等，则将next[i]的值设为next[j]，表示当前字符与前缀匹配时，下一个可能匹配的位置与前缀的下一个可能匹配的位置相同。这样可以避免重复的比较操作，减少了代码的复杂性和执行时间。 另外，这段代码在初始化时将next[0]设为-1，表示模式串的第一个字符之前没有可匹配的前缀。这与普通的next数组构建方式相同。
